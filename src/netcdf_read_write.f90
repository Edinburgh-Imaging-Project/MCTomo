! This is the module for reading and writing data with netcdf.
! Specifically, for reading and writing the samples generated by rjmcmc.
! The parameterization is implemented with Voronoi tessellation (2D/3D). Each
! Voronoi cell is represented by its location (x,y,z) and associated parameters
! (vp, vs, rho, ... , etc.)

! Samples are stored with an initial model and its changes for a Markov
! chain. For example, for a velocity change step, it stores its proposal type
! (i.e. velocity change), the generating point (e.g. index) and the perturbed
! parameters
!

! Giving up compound type and write each type separately for interopbility
module netcdf_read_write

    use netcdf
    ! for C-kind types. this is not necessary, choose your own preferred types
    use iso_c_binding
    use run_info, only : T_SAMPLE, T_RUN_INFO
    use m_settings, only : T_MCMC_SET
    implicit none

    private
    public :: netcdf_create_file
    public :: netcdf_write
    public :: T_VORO, T_PROB, T_PRIOR, T_SAMPLE, T_NC
    public :: init_nc_model

    ! static values
    ! Title descrbing the netcdf file
    character(len=*), parameter :: title = "Ensemble samples with rj-McMC &
        &sampling method and Voronoi tessellation"
    ! Name for the number of Voronoi generating points 
    character(len=*), parameter :: points_num_name="number_of_points"
    ! Name for dimensions
    character(len=*), parameter :: dimension_name="dimensions"
    ! Name for the attributes corresponding to each Voronoi generating point
    character(len=*), parameter :: parameters_dim_name="parameters"
    ! unit for points and parameters
    !character(len=*), parameter :: point_unit="<km><km><km>"
    !character(len=*), parameter :: parameter_unit="<km/s><km/s><g/cm3>"
    ! sigma name, sigma_dim name etc.
    character(len=:), parameter :: bsigma_num_name = "bodySigma"
    character(len=:), parameter :: bsigma_dim_name = "bsigma_dim"
    character(len=:), parameter :: ssigma_num_name = "surfSigma"
    character(len=:), parameter :: ssigma_dim_name = "ssigma_dim"
    character(len=:), parameter :: sigma_dim_name = "sigma_dim"
    ! source parameter name and dimention name
    character(len=:), parameter :: source_num_name = "number_of_sources"
    character(len=:), parameter :: source_dim_name = "source_dim"
    ! sample dimension name
    character(len=*), parameter :: sample_dim_name = "samples" ! dimension name

    ! string length
    integer, parameter :: STRLEN = 50
    ! Initial constant for sample
    integer, parameter :: init_stepType = 0
    integer, parameter :: init_acceptStatus = 0

    ! derived type for Voronoi tessellation (2D/3D)
    type T_VORO
        integer :: npoints
        real(c_double), dimension(:,:), allocatable :: points
        real(c_double), dimension(:,:), allocatable :: parameters
        character(len=STRLEN) :: point_unit, parameter_unit
    endtype

    ! derived type for prior information
    type T_PRIOR
        integer(c_size_t) :: min_ncells, max_ncells
        real(c_double), dimension(:), allocatable :: min_point, max_point
        real(c_double), dimension(:), allocatable :: min_parameter, max_parameter
        real(c_double), dimension(:), allocatable :: min_bsigma, max_bsigma
        real(c_double), dimension(:), allocatable :: min_ssigma, max_ssigma
        real(c_double) :: xwidth, ywidth, zwidth, twidth
    end type

    ! derived type for probability representation (prior, proposal probability
    ! etc.), using a double array to represent the probability for all the 
    ! dimensions.
    type T_PROB
        character(len=STRLEN), allocatable :: probType
        real(c_double), dimension(:), allocatable :: prob
    end type

    ! derived type to deliver data to netcdf
    type T_NC
        type(T_VORO) :: voronoi
        type(T_PRIOR) :: prior
        type(T_PROB) :: num_cells_prior
        type(T_PROB) :: points_prior, parameters_prior
        type(T_PROB) :: birth_death_propose, move_propose
        type(T_PROB) :: parameter_propose, bsigma_propose, ssigma_propose
        real(c_double), dimension(:,:), allocatable :: bsigmas, ssigmas
        character(len=STRLEN) :: bsigmaType, ssigmaType
        type(T_PROB) :: bsigmas_prior 
        type(T_PROB) :: ssigmas_prior 
        real(c_double), dimension(:,:), allocatable :: sources
        type(T_PROB) :: source_prior, source_propose
    end type

contains

    ! create a netcdf4 file and write the initial sample into it
    subroutine netcdf_create_file(filename,nc_model,init_sample)
        implicit none
        character( len=* ), intent(in) :: filename
        type(T_NC), intent(in) :: nc_model
        type(T_SAMPLE), intent(in) :: init_sample

        ! dimensionality for models (i.e. voronoi cells, data noises etc.)
        integer npts, ptsdim, pmdim
        integer nptsid, ptsdim_id, pmdim_id
        integer ptsid, pmid

        integer sigma_dim, sigma_dim_id
        integer bsigma_dim, nbsigmas
        integer ssigma_dim, nssigmas
        integer bsigma_dim_id, nbsigma_id
        integer ssigma_dim_id, nssigma_id
        integer bsigma_id, ssigma_id

        integer source_dim_id, nsource_id
        integer source_dim, nsources
        integer source_id

        ! dimensionality for samples
        integer sample_dim_id
        integer stepType_id
        integer acceptStatus_id
        integer index_id
        integer samplePoint_id, sampleParameter_id, sampleSigma_id
        integer num_cells_id, likelihood_id, residual_id, unweighted_misfit_id

        integer ncid, dimids(2)

        character(len=10) :: dimensionality

        npts = nc_model%voronoi%npoints
        ptsdim = size(nc_model%voronoi%points,1)
        pmdim = size(nc_model%voronoi%parameters,1)
        sigma_dim = 2
        bsigma_dim = size(nc_model%bsigmas,1)
        nbsigmas = size(nc_model%bsigmas,2)
        ssigma_dim = size(nc_model%ssigmas,1)
        nssigmas = size(nc_model%ssigmas,2)

        source_dim = size(nc_model%sources,1)
        nsources = size(nc_model%sources,2)

        ! Create the netcdf4 file.
        call check( nf90_create(filename, nf90_netcdf4, ncid) )

        ! Add a title attribute to describe the file
        call check( nf90_put_att(ncid, NF90_GLOBAL, 'title', title) )

        !
        ! Define dimensions
        !

        ! Define the dimensions for points and parameters
        call check( nf90_def_dim(ncid, points_num_name, npts, nptsid) )
        call check( nf90_def_dim(ncid, dimension_name, ptsdim, ptsdim_id) )
        call check( nf90_def_dim(ncid, parameters_dim_name, pmdim, pmdim_id) )

        ! Define the dimensions for data noise (sigma)
        call check( nf90_def_dim(ncid, sigma_dim_name, sigma_dim, sigma_dim_id) )
        call check( nf90_def_dim(ncid, bsigma_dim_name, bsigma_dim, bsigma_dim_id) )
        call check( nf90_def_dim(ncid, bsigma_num_name, nbsigmas, nbsigma_id) )
        call check( nf90_def_dim(ncid, ssigma_dim_name, ssigma_dim, ssigma_dim_id) )
        call check( nf90_def_dim(ncid, ssigma_num_name, nssigmas, nssigma_id) )

        ! Define the dimensions for sources
        call check( nf90_def_dim(ncid, source_dim_name, source_dim, source_dim_id) )
        call check( nf90_def_dim(ncid, source_num_name, nsources, nsource_id) )

        ! Define samples dimension
        call check( nf90_def_dim(ncid, sample_dim_name, NF90_UNLIMITED, &
            sample_dim_id) )

        !
        ! Define variables
        !

        ! Define points variable
        dimids(1) = ptsdim_id
        dimids(2) = nptsid
        call check( nf90_def_var(ncid, 'points', NF90_DOUBLE, dimids, ptsid) )
        ! Add attributes to the points variable, e.g. minimum and maximum points
        ! to indicate the prior we are using
        call check( nf90_put_att(ncid, ptsid, "valid_max_num", nc_model%prior%max_ncells) )
        call check( nf90_put_att(ncid, ptsid, "valid_min_point", nc_model%prior%min_point) )
        call check( nf90_put_att(ncid, ptsid, "valid_max_point", nc_model%prior%max_point) )
        call check( nf90_put_att(ncid, ptsid, "unit", trim(nc_model%voronoi%point_unit) ) )
        call check( nf90_put_att(ncid, ptsid, "priorType",&
            trim(nc_model%points_prior%probType) ) )
        call check( nf90_put_att(ncid, ptsid, "prior",&
            nc_model%points_prior%prob) )
        ! Add move proposal probability to attribute
        call check( nf90_put_att(ncid, ptsid, "move_proposeType", &
            trim(nc_model%move_propose%probType) ) )
        call check( nf90_put_att(ncid, ptsid, "move_propose", &
            nc_model%move_propose%prob) )
        ! Attribute indicating dimensionality i.e. 2D or 3D
        write(dimensionality,'(I0A)') ptsdim, "D"
        call check( nf90_put_att(ncid, ptsid, "dimensionality", trim(dimensionality)) )

        ! Define parameters variable
        dimids(1) = pmdim_id
        call check( nf90_def_var(ncid, 'parameters', NF90_DOUBLE, dimids, pmid) )
        ! Add attributes to the parameters variable
        call check( nf90_put_att(ncid, pmid, "valid_min_parameter", &
            nc_model%prior%min_parameter) )
        call check( nf90_put_att(ncid, pmid, "valid_max_parameter", &
            nc_model%prior%max_parameter) )
        call check( nf90_put_att(ncid, pmid, "unit", nc_model%voronoi%parameter_unit) )
        call check( nf90_put_att(ncid, pmid, "priorType",&
            trim(nc_model%parameters_prior%probType) ) )
        call check( nf90_put_att(ncid, pmid, "prior",&
            nc_model%parameters_prior%prob) )
        ! Add birth&death proposal probability to attribute
        call check( nf90_put_att(ncid, pmid, "birth_death_proposeType", &
            trim(nc_model%birth_death_propose%probType) ) )
        call check( nf90_put_att(ncid, pmid, "birth_death_propose", &
            nc_model%birth_death_propose%prob) )
        ! Add parameters change proposal probability to attribute
        call check( nf90_put_att(ncid, pmid, "parameter_proposeType", &
            trim(nc_model%parameter_propose%probType) ) )
        call check( nf90_put_att(ncid, pmid, "parameter_propose", &
            nc_model%parameter_propose%prob) )

        ! Define sigmas variable
        dimids(1) = bsigma_dim_id
        dimids(2) = nbsigma_id
        call check( nf90_def_var(ncid, 'bodySigmas', NF90_DOUBLE, dimids, bsigma_id) )
        ! Add attributes to the sigmas variable
        call check( nf90_put_att(ncid, bsigma_id, "bodySigmaType", trim(nc_model%bsigmaType) ) )
        call check( nf90_put_att(ncid, bsigma_id, "valid_min_bsigma", &
            nc_model%prior%min_bsigma) )
        call check( nf90_put_att(ncid, bsigma_id, "valid_max_bsigma", &
            nc_model%prior%max_bsigma) )
        !call check( nf90_put_att(ncid, bsigma_id, "unit", bsigma_unit) )
        call check( nf90_put_att(ncid, bsigma_id, "priorType",&
            trim(nc_model%bsigmas_prior%probType) ) )
        call check( nf90_put_att(ncid, bsigma_id, "prior",&
            nc_model%bsigmas_prior%prob) )
        ! Add bsigma change proposal probability to attribute
        call check( nf90_put_att(ncid, bsigma_id, "bsigma_proposeType", &
            trim(nc_model%bsigma_propose%probType) ) )
        call check( nf90_put_att(ncid, bsigma_id, "bsigma_propose", &
            nc_model%bsigma_propose%prob) )

        ! for surface wave
        dimids(1) = ssigma_dim_id
        dimids(2) = nssigma_id
        call check( nf90_def_var(ncid, 'surfSigmas', NF90_DOUBLE, dimids, ssigma_id) )
        ! Add attributes to the sigmas variable
        call check( nf90_put_att(ncid, ssigma_id, "surfSigmaType", trim(nc_model%ssigmaType) ) )
        call check( nf90_put_att(ncid, ssigma_id, "valid_min_ssigma", &
            nc_model%prior%min_ssigma) )
        call check( nf90_put_att(ncid, ssigma_id, "valid_max_ssigma", &
            nc_model%prior%max_ssigma) )
        !call check( nf90_put_att(ncid, ssigma_id, "unit", ssigma_unit) )
        call check( nf90_put_att(ncid, ssigma_id, "priorType",&
            trim(nc_model%ssigmas_prior%probType) ) )
        call check( nf90_put_att(ncid, ssigma_id, "prior",&
            nc_model%ssigmas_prior%prob) )
        ! Add ssigma change proposal probability to attribute
        call check( nf90_put_att(ncid, ssigma_id, "ssigma_proposeType", &
            trim(nc_model%ssigma_propose%probType) ) )
        call check( nf90_put_att(ncid, ssigma_id, "ssigma_propose", &
            nc_model%ssigma_propose%prob) )

        ! Define source variable
        dimids(1) = source_dim_id
        dimids(2) = nsource_id
        call check( nf90_def_var(ncid, 'sources', NF90_DOUBLE, dimids, source_id) )
        ! Add attributes to the source variable
        call check( nf90_put_att(ncid, source_id, "unit", trim(nc_model%voronoi%point_unit) ) )
        call check( nf90_put_att(ncid, source_id, "priorType",&
            trim(nc_model%source_prior%probType) ) )
        call check( nf90_put_att(ncid, source_id, "prior",&
            nc_model%source_prior%prob) )
        ! Add source change proposal probability to attribute
        call check( nf90_put_att(ncid, source_id, "source_proposeType", &
            trim(nc_model%source_propose%probType) ) )
        call check( nf90_put_att(ncid, source_id, "source_propose", &
            nc_model%source_propose%prob) )

        ! Define step variable describing the perturbation type 
        call check( nf90_def_var(ncid, 'stepType', NF90_INT, sample_dim_id,&
            stepType_id) )
        call check( nf90_put_att(ncid, stepType_id, "proposeType", "1 for birth,&
            & 2 for death, 3 for move, 4 for velocity change, 5 for body wave sigma &
            & change, 6 for surface wave noise change and 7 for source locations&
            & change") )

        ! Define acceptStatus variable indicating it is accepted or not
        call check( nf90_def_var(ncid, 'acceptStatus', NF90_INT, sample_dim_id,&
            acceptStatus_id) )
        call check( nf90_put_att(ncid, acceptStatus_id, "acceptStatus", "0 is &
            & not accepted, 1 is accepted") )

        ! Define index variable indicating which cell we are changing
        call check( nf90_def_var(ncid, 'index', NF90_INT, sample_dim_id,&
            index_id) )

        ! Define samplePoint variable to store the perturbed point
        dimids(1) = ptsdim_id
        dimids(2) = sample_dim_id
        call check( nf90_def_var(ncid, "samplePoint", NF90_DOUBLE, dimids,&
            samplePoint_id) )

        ! Define sampleParameter variable to store the perturbed parameter
        dimids(1) = pmdim_id
        dimids(2) = sample_dim_id
        call check( nf90_def_var(ncid, "sampleParameter", NF90_DOUBLE, dimids,&
            sampleParameter_id) )

        ! Define sampleSigma variable to store the perturbed sigma
        !dimids(1) = sigma_dim_id
        !dimids(2) = sample_dim_id
        call check( nf90_def_var(ncid, "sampleSigma", NF90_DOUBLE, sample_dim_id,&
            sampleSigma_id) )

        ! Define number of cells variable
        call check( nf90_def_var(ncid, 'num_cells', NF90_INT, sample_dim_id,&
            num_cells_id) )
        call check( nf90_put_att(ncid, num_cells_id, "valid_min", &
            nc_model%prior%min_ncells) )
        call check( nf90_put_att(ncid, num_cells_id, "valid_max", &
            nc_model%prior%max_ncells) )
        call check( nf90_put_att(ncid, num_cells_id, "num_cells_priorType", &
            trim(nc_model%num_cells_prior%probType) ) )
        call check( nf90_put_att(ncid, num_cells_id, "num_cells_prior", &
            nc_model%num_cells_prior%prob) )

        ! Define residual variable
        call check( nf90_def_var(ncid, 'residual', NF90_DOUBLE, sample_dim_id,&
            residual_id) )
        call check( nf90_put_att(ncid, residual_id, "description", "Weighted &
            & squared error between predicated data and observed data") )

        ! Define unweighted misfits variable
        call check( nf90_def_var(ncid, 'unweighted misfit', NF90_DOUBLE, sample_dim_id,&
            residual_id) )
        call check( nf90_put_att(ncid, residual_id, "description", "Unweighted &
            & squared error between predicated data and observed data") )

        ! Define likelihood variable
        call check( nf90_def_var(ncid, "Negative loglikelihood", NF90_DOUBLE, sample_dim_id,&
            likelihood_id) )
        call check( nf90_put_att(ncid, likelihood_id, "description", "Negtive log of the&
            & likelihood)") )

        !
        ! End define mode. This tells netcdf we are done defining metadata
        !

        call check( nf90_enddef(ncid) )

        !
        ! Write values to variables
        !

        ! Write the points, parameters and sigmas to the file.
        call check( nf90_put_var(ncid, ptsid, nc_model%voronoi%points) )
        call check( nf90_put_var(ncid, pmid, nc_model%voronoi%parameters) )
        call check( nf90_put_var(ncid, bsigma_id, nc_model%bsigmas) )
        call check( nf90_put_var(ncid, ssigma_id, nc_model%ssigmas) )
        call check( nf90_put_var(ncid, source_id, nc_model%sources) )

        ! Write first sample (no changes) in the file
        ! Write stepType
        call check( nf90_put_var(ncid, stepType_id, init_stepType, start = (/1/) ) )
        ! Write acceptStatus
        call check( nf90_put_var(ncid, acceptStatus_id, init_acceptStatus, start = (/1/) ) )
        ! Write index
        call check( nf90_put_var(ncid, index_id, init_sample%vindex, start = (/1/) ) )
        ! write sample point
        call check( nf90_put_var(ncid, samplePoint_id, init_sample%coord, start = (/1,1/), count = (/ptsdim,1/)) )
        ! write sample parameter
        call check( nf90_put_var(ncid, sampleParameter_id, init_sample%values, start = (/1,1/), count = (/pmdim,1/) ) )
        ! write sample noise
        call check( nf90_put_var(ncid, sampleSigma_id, [init_sample%noise0, init_sample%noise1],&
            start = (/1,1/), count = (/sigma_dim,1/) ) )
        ! write num of cells
        call check( nf90_put_var(ncid, num_cells_id, npts, start = (/1/) ) )
        ! write residuals and misfits
        call check( nf90_put_var(ncid, residual_id, init_sample%misfit, start = (/1/) ) )
        call check( nf90_put_var(ncid, residual_id, init_sample%unweighted_misfit, start = (/1/) ) )
        call check( nf90_put_var(ncid, likelihood_id, init_sample%like, start = (/1/) ) )

        ! close the file
        call check( nf90_close(ncid) )

    end subroutine netcdf_create_file

    subroutine  netcdf_write(filename,samples)
        Implicit None
        character(len=*), intent(in) :: filename
        type(T_SAMPLE), dimension(:), intent(in) :: samples

        integer:: nsamples
        integer:: ncid
        integer:: recordDimID, recordNum
        integer:: stepType_id, acceptStatus_id
        integer:: index_id
        integer:: samplePoint_id, sampleParameter_id, sampleSigma_id
        integer:: num_cells_id, likelihood_id, residual_id

        integer:: ptsdim, pmdim, sigmadim
        integer:: i

        ! allocatable variables for points, parameters, sigmas
        integer, dimension(:), allocatable :: acceptStatus
        real(c_double), dimension(:,:), allocatable :: samplePoints
        real(c_double), dimension(:,:), allocatable :: sampleParameters
        real(c_double), dimension(:,:), allocatable :: sampleSigmas

        if(size(samples)==0) return

        nsamples =  size(samples)
        ptsdim = size(samples(1)%coord)
        pmdim =  size(samples(1)%values)
        sigmadim = 2
        allocate( acceptStatus(nsamples) )
        allocate( samplePoints(ptsdim, nsamples) )
        allocate( sampleParameters(pmdim, nsamples) )
        allocate( sampleSigmas(sigmadim, nsamples) )

        ! open netcdf file
        call check( nf90_open(filename, NF90_WRITE, ncid) )

        ! get the unlimited dimension id
        call check( nf90_inquire(ncid, unlimitedDimID = recordDimID) )

        ! get the current maximum record number
        call check( nf90_inquire_dimension(ncid, recordDimID, len = recordNum) )

        ! write the new samples into associated variable
        call check( nf90_inq_varid(ncid, "stepType", stepType_id) )
        call check( nf90_put_var(ncid, stepType_id, samples%step, start = (/recordNum+1/), count = (/nsamples/) ) )
        ! Write acceptStatus
        call check( nf90_inq_varid(ncid, "acceptStatus", acceptStatus_id) )
        call ltoi(samples%accepted, acceptStatus)
        call check( nf90_put_var(ncid, acceptStatus_id, acceptStatus, start = (/recordNum+1/), count = (/nsamples/) ) )
        ! Write index
        call check( nf90_inq_varid(ncid, "index", index_id) )
        call check( nf90_put_var(ncid, index_id, samples%vindex, start = (/recordNum+1/), count = (/nsamples/) ) )
        ! extract sample point, parameters
        do i = 1, nsamples
            samplePoints(:,i)=samples(i)%coord
            sampleParameters(:,i)=samples(i)%values
        End do
        ! write sample point
        call check( nf90_inq_varid(ncid, "samplePoint", samplePoint_id) )
        call check( nf90_put_var(ncid, samplePoint_id, samplePoints, start = (/1,recordNum+1/), count = (/ptsdim,nsamples/) ) )
        ! write sample parameter
        call check( nf90_inq_varid(ncid, "sampleParameter", sampleParameter_id) )
        call check( nf90_put_var(ncid, sampleParameter_id, sampleParameters, start = (/1,recordNum+1/), count = (/pmdim,nsamples/) ) )
        ! write sample noise
        call check( nf90_inq_varid(ncid, "sampleSigma", sampleSigma_id) )
        sampleSigmas(1,:) = samples%noise0
        sampleSigmas(2,:) = samples%noise1
        call check( nf90_put_var(ncid, sampleSigma_id, sampleSigmas, start = (/1,recordNum+1/), count = (/sigmadim,nsamples/) ) )
        ! write num of cells
        call check( nf90_inq_varid(ncid, "num_cells", num_cells_id) )
        call check( nf90_put_var(ncid, num_cells_id, samples%ncells, start = (/recordNum+1/), count = (/nsamples/) ) )
        ! write residuals and misfits
        call check( nf90_inq_varid(ncid, "residual", residual_id) )
        call check( nf90_put_var(ncid, residual_id, samples%misfit, start = (/recordNum+1/), count = (/nsamples/) ) )
        call check( nf90_inq_varid(ncid, "unweighted misfit", residual_id) )
        call check( nf90_put_var(ncid, residual_id, samples%unweighted_misfit, start = (/recordNum+1/), count = (/nsamples/) ) )
        call check( nf90_inq_varid(ncid, "likelihood", likelihood_id) )
        call check( nf90_put_var(ncid, likelihood_id, samples%like, start = (/recordNum+1/), count = (/nsamples/) ) )

        ! close the file
        call check( nf90_close(ncid) )
    end subroutine  netcdf_write


    subroutine  init_nc_model(nc_model,mcmc_set,RTI)
        Implicit None
        type(T_NC), intent(inout) :: nc_model
        type(T_MCMC_SET), intent(in) :: mcmc_set
        type(T_RUN_INFO), intent(in) :: RTI
        integer i

        ! first, initialize units for points and parameters
        nc_model%voronoi%point_unit = '<km><km><km>'
        nc_model%voronoi%parameter_unit = '<km/s><km/s><g/cm3>'
        ! minimum and maximun number of cells
        nc_model%prior%min_ncells = mcmc_set%ncell_min
        nc_model%prior%max_ncells = mcmc_set%ncell_max
        ! minimun and maximum point, parameter
        allocate(nc_model%prior%min_point(3) )
        allocate(nc_model%prior%max_point(3) )
        nc_model%prior%min_point = [mcmc_set%grid%xmin, mcmc_set%grid%ymin, mcmc_set%grid%zmin]
        nc_model%prior%max_point = [mcmc_set%grid%xmax, mcmc_set%grid%ymax, mcmc_set%grid%zmax]
        allocate(nc_model%prior%min_parameter(3) )
        allocate(nc_model%prior%max_parameter(3) )
        nc_model%prior%min_parameter = [mcmc_set%vpmin, mcmc_set%vsmin, mcmc_set%rhomin]
        nc_model%prior%max_parameter = [mcmc_set%vpmax, mcmc_set%vsmax, mcmc_set%rhomax]
        ! minimum and maximum sigmas
        allocate(nc_model%prior%min_bsigma(2) )
        allocate(nc_model%prior%max_bsigma(2) )
        nc_model%prior%min_bsigma = [mcmc_set%bn0_min, mcmc_set%bn1_min]
        nc_model%prior%max_bsigma = [mcmc_set%bn0_max, mcmc_set%bn1_max]
        allocate(nc_model%prior%min_ssigma(2) )
        allocate(nc_model%prior%max_ssigma(2) )
        nc_model%prior%min_ssigma = [mcmc_set%sn0_min, mcmc_set%sn1_min]
        nc_model%prior%max_ssigma = [mcmc_set%sn0_max, mcmc_set%sn1_max]
        ! source width
        nc_model%prior%xwidth = mcmc_set%xwidth
        nc_model%prior%ywidth = mcmc_set%ywidth
        nc_model%prior%zwidth = mcmc_set%zwidth
        nc_model%prior%twidth = mcmc_set%twidth

        ! prior probability
        nc_model%num_cells_prior%probType =  'uniform'
        allocate(nc_model%num_cells_prior%prob(2))
        nc_model%num_cells_prior%prob = [mcmc_set%ncell_min, mcmc_set%ncell_max]
        nc_model%points_prior%probType =  'uniform'
        allocate(nc_model%points_prior%prob(6))
        nc_model%points_prior%prob = [mcmc_set%grid%xmin, mcmc_set%grid%xmax, mcmc_set%grid%ymin, mcmc_set%grid%ymax, mcmc_set%grid%zmin, mcmc_set%grid%zmax]
        nc_model%parameters_prior%probType =  'uniform'
        allocate(nc_model%parameters_prior%prob(6))
        nc_model%parameters_prior%prob = [mcmc_set%vpmin, mcmc_set%vpmax, mcmc_set%vsmin,&
            mcmc_set%vsmax, mcmc_set%rhomin, mcmc_set%rhomax]
        ! proposal probability
        nc_model%birth_death_propose%probType =  'prior'
        allocate(nc_model%birth_death_propose%prob(6))
        nc_model%birth_death_propose%prob = [mcmc_set%vpmin, mcmc_set%vpmax, mcmc_set%vsmin,&
            mcmc_set%vsmax, mcmc_set%rhomin, mcmc_set%rhomax]
        ! move probability
        nc_model%move_propose%probType =  'Gauss'
        allocate(nc_model%move_propose%prob(3))
        nc_model%move_propose%prob = [mcmc_set%pd, mcmc_set%pd, mcmc_set%pd]
        ! parameters change
        nc_model%parameter_propose%probType =  'Gauss'
        allocate(nc_model%parameter_propose%prob(3))
        nc_model%parameter_propose%prob = [mcmc_set%sigma_vp, mcmc_set%sigma_vs, mcmc_set%sigma_rho]
        ! data noise
        nc_model%bsigmas_prior%probType =  'uniform'
        allocate(nc_model%bsigmas_prior%prob(4))
        nc_model%bsigmas_prior%prob = [mcmc_set%bn0_min,mcmc_set%bn0_max,mcmc_set%bn1_min,mcmc_set%bn1_max ]
        nc_model%bsigma_propose%probType =  'Gauss'
        allocate(nc_model%bsigma_propose%prob(2))
        nc_model%bsigma_propose%prob = [mcmc_set%sigma_bn0,mcmc_set%sigma_bn1 ]

        nc_model%ssigmas_prior%probType =  'uniform'
        allocate(nc_model%ssigmas_prior%prob(4))
        nc_model%ssigmas_prior%prob = [mcmc_set%sn0_min,mcmc_set%sn0_max,mcmc_set%sn1_min,mcmc_set%sn1_max ]
        nc_model%ssigma_propose%probType =  'Gauss'
        allocate(nc_model%ssigma_propose%prob(2))
        nc_model%ssigma_propose%prob = [mcmc_set%sigma_sn0,mcmc_set%sigma_sn1 ]
        ! sources
        nc_model%source_prior%probType =  'uniform'
        allocate(nc_model%source_prior%prob(4))
        nc_model%source_prior%prob = [mcmc_set%xwidth,mcmc_set%ywidth,mcmc_set%zwidth,mcmc_set%twidth ]
        nc_model%source_propose%probType =  'Gauss'
        allocate(nc_model%source_propose%prob(4))
        nc_model%source_propose%prob = [mcmc_set%sigma_x,mcmc_set%sigma_y, mcmc_set%sigma_z, mcmc_set%sigma_t ]

        ! put initial data to nc model
        ! Voronoi, i.e. points and parameters
        nc_model%voronoi%npoints = RTI%ncells
        allocate(nc_model%voronoi%points(3,RTI%ncells) )
        allocate(nc_model%voronoi%parameters(3,RTI%ncells) )
        nc_model%voronoi%points = RTI%points(:,1:RTI%ncells)
        nc_model%voronoi%parameters = RTI%parameters(:,1:RTI%ncells)
        ! sigmas
        if(mcmc_set%sigdep /= 0)then
            nc_model%bsigmaType = "linearTolength"
            nc_model%ssigmaType = "linearTolength"
        else
            nc_model%bsigmaType = "fixed"
            nc_model%ssigmaType = "fixed"
        endif
        allocate( nc_model%bsigmas(2,size(RTI%bnoise0)) )
        do i = 1, size(RTI%bnoise0)
            nc_model%bsigmas(:,i) = [RTI%bnoise0(i), RTI%bnoise1(i)]
        enddo

        allocate( nc_model%ssigmas(2,size(RTI%snoise0)) )
        do i = 1, size(RTI%snoise0)
            nc_model%ssigmas(:,i) = [RTI%snoise0(i), RTI%snoise1(i)]
        enddo

        ! sources
        allocate( nc_model%sources(size(RTI%locations,1),size(RTI%locations,2)) )
        nc_model%sources = RTI%locations

        return
        
    end subroutine  init_nc_model

    subroutine check(status)
        integer, intent(in) :: status

        if(status /= nf90_noerr) then
            write(*,*) trim(nf90_strerror(status))
            stop 2
        endif
    end subroutine check


    subroutine  ltoi(lvar,ivar)
        Implicit None
        logical(c_bool), dimension(:), intent(in) :: lvar
        integer, dimension(:), intent(out) :: ivar

        where( lvar )
            ivar =  1
        elsewhere
            ivar =  0
        endwhere
        !do i =  1, size(lvar)
        !    if(lvar(i))then
        !        ivar(i) =  1
        !    else
        !        ivar(i) =  0
        !    endif
        !enddo

    end subroutine ltoi


end module netcdf_read_write
